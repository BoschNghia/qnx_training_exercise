#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define BUFFER_SIZE 1024
#define CMD_READ 'r'
#define CMD_WRITE 'w'
#define CMD_EXIT 'x'


char buffer[BUFFER_SIZE];

static int is_alphanumeric(char c) {
    return 
        (('0' <= c) && ('9' >= c)) ||
        (('A' <= c) && ('Z' >= c)) ||
        (('a' <= c) && ('z' >= c));
}

// Strips trailing whitespace characters from a string.
static void strip_trailing_whitespace(char* str) {
    if (str == NULL) {
        return;
    }

    size_t length = strlen(str);
    if (length == 0) {
        return;
    }

    // Start from the end of the string and work backwards
    int i = length - 1;
    while (i >= 0 && (isspace((unsigned char)str[i]))) {
        i--;
    }

    // Place the null terminator after the last non-whitespace character
    str[i + 1] = '\0';
}

// Function to print a usage message
static void print_usage() {
    printf("Buffer: %p/%d\n", buffer, BUFFER_SIZE);
    printf("Usage:\n");
    printf("* To read and print the bytes (as ASCII characters): `%c <offset> <number of bytes>`\n", CMD_READ);
    printf("* To write a text string (no whitespace) to buffer: `%c <offset> <string>`\n", CMD_WRITE);
    printf("* To exit: `%c`\n", CMD_EXIT);
    printf("\nAddresses and sizes must be within the range 0 to %d.\n", BUFFER_SIZE - 1);
}

static void dump(const int offset, const int num_bytes) {
    printf("%p/%d:\n  `", (buffer + offset), num_bytes);
    for (int i = 0; i < num_bytes; i++) {
        char c = buffer[offset + i];
        // Print the character representation
        if (is_alphanumeric(c)) {
            printf("0x%02X ('%c') | ", c, c);
        } else {
            printf("0x%02X | ", c);
        }
    }
    printf("`\n");
}

static void mread(const char* command) {
    int offset, num_bytes;
    if (sscanf(command, "r %d %d", &offset, &num_bytes) == 2) {
        // Check for valid address and byte count
        if ((offset >= 0) && (offset < BUFFER_SIZE) && (num_bytes > 0) && ((offset + num_bytes) <= BUFFER_SIZE)) {
            dump(offset, num_bytes);
        } else {
            printf("Error: Invalid address or number of bytes. Please check the range.\n");
        }
    } else {
        printf("Error: Invalid format for 'r' command. Use 'r <offset> <number of bytes>'\n");
    }

    printf("\n");
}

static void mwrite(const char* command) {
    int offset, num_bytes;

    if (sscanf(command, "w %d", &offset) == 1) {
        int i = 2;
        while (command[i] != '\0' && command[i] != ' ') {
            i++;
        }

        while (' ' == command[i]) {
            i++;
        }

        size_t num_bytes = strlen(command + i);
        if ((offset >= 0) && (offset < BUFFER_SIZE) && (num_bytes > 0) && ((offset + num_bytes) <= BUFFER_SIZE)) {
            strcpy(buffer + offset, command + i);
            printf("=> %p/%ld", (buffer + offset), num_bytes);
        } else {
            printf("Error: Invalid address or number of bytes. Please check the range.\n");
        }
    } else {
        printf("Error: Invalid format for 'w' command. Use `%c <offset> <string>`", CMD_WRITE);
    }

    printf("\n");
}

int main() {
    char line[256];
    char cmd_code = '\0';

    printf("\n\nDisclaimer: This application was generated by GenAI.\n\n");

    printf("Command-line Memory Editor\n");
    print_usage();

    // Initialize the memory block with zeros
    memset(buffer, 0, BUFFER_SIZE);

    // Main command loop
    while (CMD_EXIT != cmd_code) {
        printf("> ");
        if (fgets(line, sizeof(line), stdin) == NULL) {
            printf("Error reading input.\n");
            break;
        }

        strip_trailing_whitespace(line);

        // Parse the command from the input line
        cmd_code = line[0];

        switch (cmd_code) {
            case CMD_READ:
                mread(line);
                break;

            case CMD_WRITE:
                mwrite(line);
                break;

            case CMD_EXIT:
                break;

            default:
                printf("Unknown command: `%c`!\n", cmd_code);
                cmd_code = CMD_EXIT;
                break;
        }
    }

    printf("Terminating ...\n");

    return 0;
}
